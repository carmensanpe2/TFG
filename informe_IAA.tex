\documentclass[10pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{afterpage}
\usepackage{verbatim}
\usepackage[T1]{fontenc}
\usepackage{textgreek}

\newcommand{\grad}{$^{\circ}$}

\newenvironment{simplechar}{%
   \catcode`\$=12
   \catcode`\&=12
   \catcode`\#=12
   \catcode`\^=12
   \catcode`\_=12
   \catcode`\~=12
   \catcode`\%=12}{}
%------------------------------------------------------------------
\begin{document}
\title{INFORME DE PRÁCTICAS\\ Instituto de Astrofísica de Andalucía (IAA-CSIC)}
\date{6 Julio 2020 - 7 Agosto 2020}
\author{Carmen Sánchez Pérez\\[0.5cm]{Supervisor: A. Luque}}
\maketitle
%------------------------------------------------------------}
\begin{simplechar}
\section{Introducción}
Estas prácticas forman parte del programa de prácticas curriculares ofertado por el Grado en Física de la Universidad de Sevilla y en el cual se pretende fomentar la inserción del estudiante en el mundo laboral mediante la adquisición de experiencia en su campo de estudio. La entidad colaboradora ha sido el Instituto de Astrofísica de Andalucía (IAA-CSIC) y todas las tareas de las que constaron las prácticas fueron supervisadas por el investigador Alejandro Luque, del departamento de Sistema Solar.
 
\bigskip
El objetivo principal de estas prácticas en el IAA ha consistido en familiarizarse con el ambiente de trabajo y herramientas de colaboración en el marco de la investigación, a través de la realización de diversas tareas cortas, relacionadas con el estudio de la dispersión de la luz emitida por un rayo en las nubes y su detección por parte de un satélite, mediante simulaciones en lenguaje de programación Julia. Dada la excepcionalidad impuesta por el COVID-19, todas las actividades que a continuación se detallan, se desarrollaron de forma telemática:

\section{Preparación previa}
Antes de comenzar con la primera tarea, se realizó una lectura del artículo sobre CloudScat.jl, un código de Montecarlo desarrollado para Julia por el supervisor, que permite predecir la señal observada por un satélite debido a una fuente óptica ubicada dentro o sobre una nube de tormenta y teniendo en cuenta tanto la dispersión o scattering de Rayleigh como el de Mie. En el artículo se presentaban aspectos teóricos junto varios ejemplos del uso de este código, los cuales se usaron como base para el desarrollo de las prácticas.

\bigskip
Durante la asignatura de óptica en el Grado en Física, se había estudiado la dispersión de Rayleigh, pero no se tenían conocimientos sobre la dispersión de Mie, por lo que también fue necesario informarse sobre estos temas antes de empezar las tareas.
 
\bigskip
Se sabe que la luz natural procedente del Sol o luz blanca es un tipo de radiación electromagnética que resulta de la superposición otras ondas electromagnéticas, cada una con una frecuencia distinta. La dispersión ocurre cuando esa luz blanca, al atravesar un cierto medio material, se divide en las longitudes de onda que la componen, pudiéndose apreciar así diversos colores. 

\bigskip
El scattering de Rayleigh ocurre cuando la luz se dispersa debido a partículas de tamaño inferior al 10\% de la longitud de onda incidente, por lo que este tipo de scattering tiene una fuerte dependencia tanto del tamaño de la partícula como de la longitud de onda. El scattering tiene lugar cuando la luz se dispersa por partículas de tamaño mayor al 10\% de la longitud de onda que incide sobre ellas. En este caso, la dispersión de Mie es aproximadamente independiente de la longitud de onda y la dispersión es mayor hacia la dirección de en frente cuanto mayor es el tamaño de la partícula.

\section{Tarea 1: Halo}

La primera tarea consistió en estudiar el halo que se forma alrededor de una nube cuando esta dispersa un rayo de luz y ver la dependencia del halo con la altura de la nube y el número de partículas. Para ello, se utilizó el ejemplo de Julia \textit{sample.jl}, incluido en el código de CloudScat, descargado del repositorio de GitHub de A. Luque. Para el manejo de los códigos se decidió utilizar el IDE Juno para Julia por tener una interfaz más cómoda e intuitiva para modificarlos. Tras ejecutar la simulación, los resultados se guardan como un archivo con extensión \textit{.h5}, los cuales contienen una matriz cuadrada con la misma dimensión que el número de píxeles (1024x1024) con los resultados de la simulación. Estos resultados podían representarse a partir de otros dos archivos de Python preexistentes en CloudScat que podía ejecutarse desde el símbolo del sistema: \textit{plot_photo.py} y \textit{plot_image.py}. En concreto, en la línea de comandos debía escribirse:

\medskip
\texttt{python plot_photo.py (nombre del archivo).h5 ---observer=1}

\medskip
\noindent
Este comando indica que se use Python para representar gráficamente el archivo que hemos obtenido para 1 observador de acuerdo con el archivo \textit{plot_photo.py}. Así se obtiene una curva que representa la simulación del flujo de fotones normalizado que emerge de la nube y se detecta por el satélite.

\bigskip
La otra línea sería análoga a la anterior: 

\medskip
\texttt{python plot_image.py (nombre del archivo).h5 ---observer=1}

\medskip
\noindent
Pero ahora \textit{image_photo.py} permite representar gráficamente todo el campo de visión de la cámara del satélite, la cual vería la luz dispersada por la nube de la simulación. En este caso se obtendría un único punto luminoso como consecuencia de que sólo se distinguiría la dispersión debida al scattering de Mie por las gotas de la nube. 

\bigskip
Para apreciar la dispersión de Rayleigh se debe añadir el comando \texttt{---log} para representar los datos en escala logarítmica, logrando así filtrar la dispersión de Mie y finalmente se vería un tenue halo formado por el scattering de Rayleigh. Asimismo, pueden observarse algunas manchas o clústeres. Estos clústeres no poseen un significado físico, sino más bien se producen por la agrupación de varios pixeles durante la simulación de las imágenes. De acuerdo con la explicación del supervisor: “Este efecto no es físico: es un artefacto de la forma de simular la formación de imágenes. El código simula fotones y en teoría cada fotón es independiente y al ser captado debería influir sólo sobre un píxel. Sin embargo, es conveniente aprovechar al máximo cada fotón, lo que hace que aparezcan a veces estas manchas”. Aumentando el número de fotones simulados, se consigue que el halo se aprecie con mayor definición y disminuya el tamaño de estos clústeres.


\section{Tarea 2: Tronco cónico I}
Para la segunda tarea se simuló una nube con forma de tronco cónico y se vio cómo influye el ángulo del cono en la detección de la luz que emerge de la cara lateral de la nube por parte del satélite. Con este fin, nos basamos como guía en el archivo de ejemplo de \textit{cloud_geometry.jl} de CloudScat y modificamos el código nuevamente con Julia en el IDE Juno. Lo primero de todo fue definir la geometría de la nube mediante la línea de código:

\medskip
\noindent
\texttt{cone = Cone(7 * co.kilo, 15 * co.kilo, 0, 0, 25 * co.kilo, 0.75)}

\medskip
\noindent
de acuerdo con las instrucciones para definir la geometría de los comentarios:

\medskip
\texttt{Cone(zbottom, ztop, xvertex, yvertex, zvertex, m)}

\medskip
Siendo m la pendiente del cono. El multiplicar por \texttt{* co.kilo} simplemente indica que las constantes que hemos definido están en kilómetros al realizar la simulación con CloudScat. Tras ejecutar la simulación, el output proporcionaba, además de los resultados guardados nuevamente en un archivo de extensión .h5, unas líneas de código que al ejecutarlas en el software Mathematica permitían visualizar la geometría nube. Para representar el resultado de la simulación, en la misma línea que la tarea anterior, utilizamos de nuevo el archivo image_photo.py en Python y usamos la escala logarítmica. 


\bigskip
Por trigonometría, se sabe que el ángulo del tronco cónico
\straighttheta\, está relacionado con la pendiente m a través de la expresión: 
\begin{equation*}
m=\tan\theta
\end{equation*}

Por tanto, para ver cómo depende la detección de la luz del ángulo del cono, repetimos la simulación anterior para distintos valores de m. Con ello se observó que, a mayor pendiente y, por tanto, a mayor ángulo, menos suave es la forma de tronco cónico que se aprecia a partir de la detección de la luz que emerge de la nube. Además, también a mayor ángulo, también se empezaban a observar algunos clústeres de píxeles como los de la tarea anterior.


\section{Tarea 3: Tutoriales}
La siguiente tarea consistió en familiarizarse un poco más tanto con el lenguaje de Julia como con Python y los cuadernos de Jupyter, así como los IDE de PyCharm y Atom/Juno. Para ello, se siguieron varios tutoriales online gratuitos ofrecidos por las mismas páginas de soporte técnico de estos softwares/lenguajes y el libro de Python para principiantes de la editorial Springer.

\bigskip
Por otro lado, también se siguieron algunos tutoriales online para familiarizarse con los cuadernos de Jupyter, incluidos en el navegador de Anaconda, pues para la siguiente tarea utilizaríamos myBinder, un servicio gratuito que permite compartir Jupyter Notebooks ejecutables y trabajar con ellos directamente online si no se tienen simulaciones muy costosas. Otra desventaja que presenta este servicio es que los cambios realizados en los códigos o en el repositorio no se guardan y, por tanto, cada vez que se modificaba el código, era necesario descargarse el cuaderno de Jupyter con la modificación para no perderla si el kernel del cuaderno perdía la conexión y no se reconectaba, lo cual ocurría a menudo.

\section{Tronco cónico II}
Siguiendo con la tarea de la nube con tronco cónico, el supervisor, A. Luque, compartió un repositorio en myBinder con un cuaderno de Jupyter ejecutable con una versión modificada del código de la nube de tronco cónico. Se tenía que modificar el código de Julia para extraer, como función del ángulo del cono, la intensidad (radiancia) que detecta el satélite y ver cómo varía. Además, se estudió si había diferencias en la dependencia con el ángulo del cono al cambiar la geometría de la fuente.

\bigskip
Recordando la relación trigonométrica entre el ángulo del cono y la pendiente m, para m=0.75, el ángulo del cono corresponde a aproximadamente a 37\grad. Luego, para ver cómo dependía la radiancia del ángulo, tendríamos que llevar a cabo varias simulaciones para distintos valores de la pendiente. Eso se conseguía utilizando un bucle for en el código y estableciendo que la función que definía los parámetros que utilizaría CloudScat como input, dependiera explícitamente de m. Se decidió que la pendiente variara entre 0.75 y 3, con saltos de 0.75 para tener 4 simulaciones, en total, que no fueran muy costosas, correspondientes a los ángulos 37\grad, 56\grad, 66\grad y 72\grad.

\bigskip
Para el dominio computacional en las simulaciones anteriores de la nube con forma de tronco cónico, escogimos uno que se adaptase a dicha forma, pero más adelante vimos que no es la opción más adecuada porque parte de la dispersión de Rayleigh a estudio quedaba fuera del dominio. Entonces nuestro supervisor nos aconsejó utilizar un cilindro lo suficientemente grande como dominio computacional para que, como los fotones pueden interaccionar con moléculas del aire fuera de la nube (dispersión de Rayleigh), ninguna o el mínimo número posible de interacciones quedara fuera de nuestro dominio.

\bigskip
Tras esto, el supervisor nos ayudó a unir los resultados de las 4 simulaciones para poder representarlas todas en la misma gráfica, llegándose a la conclusión de que, realmente, la radiancia en una línea de visión apenas tenía dependencia con el ángulo del cono. Para comprobar que esto no fuera porque la fuente de luz se había definido como un canal vertical largo, se decidió cambiar la geometría de la fuente para hacerla puntual estableciendo en el código: \texttt{source_a = source_b}. Sin embargo, tampoco se apreciaba una dependencia significativa entre la radiancia y la pendiente del cono tras modificar la geometría de la fuente.


\end{simplechar}
\end{document}